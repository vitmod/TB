#!/bin/sh

################################################################################
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
################################################################################

. /usr/share/tb/functions

# create directories
/bin/busybox mkdir -p /dev
/bin/busybox mkdir -p /proc
/bin/busybox mkdir -p /sys
/bin/busybox mkdir -p /var
/bin/busybox mkdir -p /flash
/bin/busybox mkdir -p /sysroot
/bin/busybox mkdir -p /storage

# mount all needed special filesystems
/bin/busybox mount -t devtmpfs devtmpfs /dev
/bin/busybox mount -t proc proc /proc
/bin/busybox mount -t sysfs sysfs /sys
/bin/busybox mount -t tmpfs tmpfs /var

UPDATE_DIR=/storage/.update
IMAGE_KERNEL="kernel.img"

BOOT_STEP="start"

# hide kernel log messages on console
echo '1 4 1 7' > /proc/sys/kernel/printk

# set ondemand up_threshold
if [ -e /sys/devices/system/cpu/cpufreq/ondemand/up_threshold ] ; then
  echo 50 > /sys/devices/system/cpu/cpufreq/ondemand/up_threshold
fi

# run platform_init script if exists
if [ -f "./platform_init" ]; then
  ./platform_init
fi

# clear screen and hide cursor
clear
hidecursor

# parse command line arguments
for arg in $(cat /proc/cmdline); do
  case $arg in
    BOOT_IMAGE=*)
      IMAGE_KERNEL="${arg#*=}"
      ;;
    boot=*)
      boot="${arg#*=}"
      ;;
    disk=*)
      disk="${arg#*=}"
      ;;
  esac
done

debug_shell() {
  echo "### Starting debugging shell... type 'exit' to quit ###"
  showcursor
  sh </dev/tty1 >/dev/tty1 2>&1
}

error() {
  echo "*** Error in $BOOT_STEP: $1: $2 ***"
  debug_shell
}

# Mount handlers
# $1:target, $2:mountpoint, $3:mount options, [$4:fs type]
mount_common() {
  MOUNT_OPTIONS="-o $3"
  [ -n "$4" ] && MOUNT_OPTIONS="-t $4 $MOUNT_OPTIONS"
  for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; do
    ERR_ENV=1
    mount $MOUNT_OPTIONS $1 $2 >/dev/null 2>&1
    [ "$?" -eq "0" ] && ERR_ENV=0 && break
    usleep 1000000
  done
  [ "$ERR_ENV" -ne "0" ] && error "mount_common" "Could not mount $1"
}

mount_part() {
  MOUNT_TARGET="${1#*=}"
  case $1 in
    UUID=*|/*)
      MOUNT_CMD="mount_common"
      MOUNT_TARGET="$1"
      ;;
    *)
      error "mount_part" "Unknown filesystem $1"
      ;;
  esac
  $MOUNT_CMD "$MOUNT_TARGET" "$2" "$3" "$4"
}

update() {
  if [ -f "$UPDATE_DIR/$1" -a -f "$2" ]; then
    mount -o remount,rw /flash
    start_progress percent "updating $1... " $2 $(stat -t "$UPDATE_DIR/$1" | cut -d" " -f2) \
      "dd if=$UPDATE_DIR/$1 of=$2 bs=1M conv=fsync 2>/dev/null" "done" "failed"
    mount -o remount,ro /flash
  fi
}

load_splash() {
  if [ -e /dev/fb0 ]; then
    ply-image /splash/splash.png > /dev/null 2>&1
  fi
}

load_kmap() {
  if [ -e /keymap ]; then
    loadkmap < /keymap
  fi
}

do_reboot() {
  start_progress spinner "system reboots now... "
  mountpoint -q /flash && umount /flash
  mountpoint -q /storage && umount /storage
  sync
  reboot
}

force_fsck() {
  echo -en "\033[$(($(stty size | cut -d" " -f1)-5));1H"
  echo "Filesystem corruption has been detected"
  echo "To prevent an automatic repair attempt continuing"
  echo "press any key or power off your system within the next 60 seconds"
  echo ""
  read -t60 -n1
  # exit status is 0 if input is available. > 128 if the timeout is reached
  if [ "$?" -ne "0" -o "$?" -gt "128" ] ; then
    echo "repairing filesystem.."
    echo ""
    /sbin/e2fsck -y $disk
    FSCK_RET="$?"
    if [ "$(( $FSCK_RET & 8 ))" = 8 ] ; then
      echo "Forced fsck failed. Your system is broken beyond repair"
      echo ""
      echo "Press enter to shutdown now"
      echo ""
      read fubar
      poweroff
    fi
    do_reboot
  else
    start_progress spinner "shutting down... "
    sync
    poweroff
  fi
}

check_disks() {
  /sbin/e2fsck -p $disk > /dev/null 2>&1
  FSCK_RET="$?"
  # FSCK_RET is the bit-wise OR of the exit codes for each filesystem that is checked.
  if [ "$(( $FSCK_RET & 4 ))" = 4 ] ; then
    force_fsck
  elif [ "$(( $FSCK_RET & 2 ))" = 2 ] ; then
    do_reboot
  fi
}

mount_flash() {
  mount_part "$boot" "/flash" "ro,noatime"
}

mount_storage() {
  mount_part "$disk" "/storage" "rw,noatime"
}

check_update() {
  UPDATE_TAR=`ls -1 "$UPDATE_DIR"/*.tar 2>/dev/null | head -n 1`
  if [ -f "$UPDATE_TAR" ] ; then
    echo -en "\033[$(($(stty size | cut -d" " -f1)-5));1H"
    start_progress spinner "Extracting $(basename $UPDATE_TAR)... " \
      "tar -xf $UPDATE_TAR -C $UPDATE_DIR &>/dev/null" "done" "failed"
    if [ "$?" -ne "0" ] ; then
      rm -rf $UPDATE_DIR/[0-9a-zA-Z]* &>/dev/null
      start_progress countdown "$UPDATE_TAR corrupted. normal startup in 10s... "
      return 0
    fi
    rm -rf "$UPDATE_TAR" &>/dev/null
  fi

  if [ -f "$UPDATE_DIR/kernel.img" -a -f "$UPDATE_DIR/root.sqfs" ] ; then
    update "$IMAGE_KERNEL" "/flash/$IMAGE_KERNEL"
    update "root.sqfs" "/flash/root.sqfs"
    rm -rf $UPDATE_DIR/[0-9a-zA-Z]* &>/dev/null
    do_reboot
  fi
}

prepare_sysroot() {
  mount_part "/flash/root.sqfs" "/sysroot" "ro,loop"

  mkdir -p /storage/.cache
  mkdir -p /storage/.config
  false | cp -iR /sysroot/usr/config/* /storage/.config >/dev/null 2>&1

  mount --move /flash /sysroot/flash
  mount --move /storage /sysroot/storage
}

# main boot sequence
for BOOT_STEP in \
    load_splash \
    load_kmap \
    check_disks \
    mount_flash \
    mount_storage \
    check_update \
    prepare_sysroot; do
  $BOOT_STEP
done

BOOT_STEP=final

# move some special filesystems
/bin/busybox mount --move /dev /sysroot/dev
/bin/busybox mount --move /proc /sysroot/proc
/bin/busybox mount --move /sys /sysroot/sys
/bin/busybox mount --move /var /sysroot/var

if [ -f /sysroot/storage/.please_resize_me ] ; then
  INIT_UNIT="--unit=fs-resize.target"
fi

# switch to new sysroot and start real init
exec /bin/busybox switch_root /sysroot /usr/lib/systemd/systemd $INIT_ARGS $INIT_UNIT

error "switch_root" "Error in initramfs. Could not switch to new root"
