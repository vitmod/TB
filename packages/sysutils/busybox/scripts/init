#!/bin/sh

################################################################################
#      This file is part of OpenELEC - http://www.openelec.tv
#      Copyright (C) 2009-2014 Stephan Raue (stephan@openelec.tv)
#      Copyright (C) 2010-2011 Roman Weber (roman@openelec.tv)
#      Copyright (C) 2012 Yann CÃ©zard (eesprit@free.fr)
#
#  OpenELEC is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 2 of the License, or
#  (at your option) any later version.
#
#  OpenELEC is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with OpenELEC.  If not, see <http://www.gnu.org/licenses/>.
################################################################################

# create directories
/bin/busybox mkdir -p /dev
/bin/busybox mkdir -p /proc
/bin/busybox mkdir -p /sys
/bin/busybox mkdir -p /var
/bin/busybox mkdir -p /flash
/bin/busybox mkdir -p /sysroot
/bin/busybox mkdir -p /storage

# mount all needed special filesystems
/bin/busybox mount -t devtmpfs devtmpfs /dev
/bin/busybox mount -t proc proc /proc
/bin/busybox mount -t sysfs sysfs /sys
/bin/busybox mount -t tmpfs tmpfs /var

UPDATE_DIR=/storage/.update
IMAGE_KERNEL="KERNEL"
IMAGE_SYSTEM="SYSTEM"

BOOT_STEP="start"
RUN_FSCK_DISKS=""

# hide kernel log messages on console
echo '1 4 1 7' > /proc/sys/kernel/printk

# set ondemand up_threshold
if [ -e /sys/devices/system/cpu/cpufreq/ondemand/up_threshold ] ; then
  echo 50 > /sys/devices/system/cpu/cpufreq/ondemand/up_threshold
fi

# run platform_init script if exists
if [ -f "./platform_init" ]; then
  ./platform_init
fi

# clear screen and hide cursor
clear
if [ -f /sys/devices/virtual/graphics/fbcon/cursor_blink ] ; then
  echo 0 > /sys/devices/virtual/graphics/fbcon/cursor_blink
fi

# parse command line arguments
for arg in $(cat /proc/cmdline); do
  case $arg in
    BOOT_IMAGE=*)
      IMAGE_KERNEL="${arg#*=}"
      ;;
    SYSTEM_IMAGE=*)
      IMAGE_SYSTEM="${arg#*=}"
      ;;
    boot=*)
      boot="${arg#*=}"
      case $boot in
        /dev/*|LABEL=*|UUID=*)
          RUN_FSCK_DISKS="$RUN_FSCK_DISKS $boot"
          ;;
      esac
      ;;
    disk=*)
      disk="${arg#*=}"
      case $disk in
        /dev/*|LABEL=*|UUID=*)
          RUN_FSCK_DISKS="$RUN_FSCK_DISKS $disk"
          ;;
      esac
      ;;
  esac
done

debug_shell() {
  echo "### Starting debugging shell... type 'exit' to quit ###"
  echo 0 > /sys/devices/virtual/graphics/fbcon/cursor_blink
  sh </dev/tty1 >/dev/tty1 2>&1
}

error() {
  echo "*** Error in $BOOT_STEP: $1: $2 ***"
  debug_shell
}

# Mount handlers
# $1:target, $2:mountpoint, $3:mount options, [$4:fs type]
mount_common() {
  MOUNT_OPTIONS="-o $3"
  [ -n "$4" ] && MOUNT_OPTIONS="-t $4 $MOUNT_OPTIONS"
  for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; do
    ERR_ENV=1
    mount $MOUNT_OPTIONS $1 $2 >/dev/null 2>&1
    [ "$?" -eq "0" ] && ERR_ENV=0 && break
    usleep 1000000
  done
  [ "$ERR_ENV" -ne "0" ] && error "mount_common" "Could not mount $1"
}

mount_part() {
  MOUNT_TARGET="${1#*=}"
  case $1 in
    LABEL=*|UUID=*|/*)
      MOUNT_CMD="mount_common"
      MOUNT_TARGET="$1"
      ;;
    *)
      error "mount_part" "Unknown filesystem $1"
      ;;
  esac
  $MOUNT_CMD "$MOUNT_TARGET" "$2" "$3" "$4"
}

update() {
  if [ -f "$UPDATE_DIR/$2" -a -f "$3" ]; then
    echo "updating $1..."
    mount -o remount,rw /flash
    mv $UPDATE_DIR/$2 $3 2>/dev/null
    mount -o remount,ro /flash
    sync
  fi
}

load_splash() {
  if [ -e /dev/fb0 ]; then
    ply-image /splash/splash.png > /dev/null 2>&1
  fi
}

load_kmap() {
  if [ -e /keymap ]; then
    loadkmap < /keymap
  fi
}

do_reboot() {
  echo "System reboots now..."
  mountpoint -q /flash && umount /flash
  mountpoint -q /storage && umount /storage
  sync
  reboot
}

force_fsck() {
  echo "Filesystem corruption has been detected"
  echo "To prevent an automatic repair attempt continuing"
  echo "press any key or power off your system within the next 60 seconds"
  echo ""
  read -t60 -n1
  # exit status is 0 if input is available. > 128 if the timeout is reached
  if [ "$?" -ne "0" -o "$?" -gt "128" ] ; then
    echo "repairing filesystem.."
    echo ""
    /sbin/fsck -T -M -y $RUN_FSCK_DISKS
    FSCK_RET="$?"
    if [ "$(( $FSCK_RET & 8 ))" = 8 ] ; then
      echo "Forced fsck failed. Your system is broken beyond repair"
      echo ""
      echo "Press enter to shutdown now"
      echo ""
      read fubar
      poweroff
    fi
    do_reboot
  else
    echo "shutting down..."
    sync
    poweroff
  fi
}

check_disks() {
  if [ -n "$RUN_FSCK_DISKS" ]; then
    /sbin/fsck -T -M -p -a $RUN_FSCK_DISKS > /dev/null 2>&1
    FSCK_RET="$?"
    # FSCK_RET is the bit-wise OR of the exit codes for each filesystem that is checked.
    if [ "$(( $FSCK_RET & 4 ))" = 4 ] ; then
      force_fsck
    elif [ "$(( $FSCK_RET & 2 ))" = 2 ] ; then
      do_reboot
    fi
  fi
}

mount_flash() {
  mount_part "$boot" "/flash" "ro,noatime"
}

mount_storage() {
  if [ -n "$disk" ]; then
    mount_part "$disk" "/storage" "rw,noatime"
  else
    mount -t tmpfs none /storage
  fi
}

check_update() {
  UPDATE_TAR=`ls -1 "$UPDATE_DIR"/*.tar 2>/dev/null | head -n 1`
  if [ -f "$UPDATE_TAR" ] ; then
    echo "Extracting $(basename $UPDATE_TAR)..."
    tar -xf "$UPDATE_TAR" -C $UPDATE_DIR &>/dev/null
    if [ "$?" -ne "0" ] ; then
      echo "$UPDATE_TAR corrupted. normal startup in 10s"
      rm -rf $UPDATE_DIR/[0-9a-zA-Z]* &>/dev/null
      usleep 10000000
      return 0
    fi
    rm -rf "$UPDATE_TAR" &>/dev/null
  fi

  if [ -f "$UPDATE_DIR/KERNEL" -a -f "$UPDATE_DIR/SYSTEM" ] ; then
    update "Kernel" "KERNEL" "/flash/$IMAGE_KERNEL"
    update "System" "SYSTEM" "/flash/$IMAGE_SYSTEM"
    rm -rf $UPDATE_DIR/[0-9a-zA-Z]* &>/dev/null
    do_reboot
  fi
}

prepare_sysroot() {
  mount_part "/flash/$IMAGE_SYSTEM" "/sysroot" "ro,loop"

  mkdir -p /storage/.cache
  mkdir -p /storage/.config
  false | cp -iR /sysroot/usr/config/* /storage/.config >/dev/null 2>&1

  mount --move /flash /sysroot/flash
  mount --move /storage /sysroot/storage
}

# main boot sequence
for BOOT_STEP in \
    load_splash \
    load_kmap \
    check_disks \
    mount_flash \
    mount_storage \
    check_update \
    prepare_sysroot; do
  $BOOT_STEP
done

BOOT_STEP=final

# move some special filesystems
/bin/busybox mount --move /dev /sysroot/dev
/bin/busybox mount --move /proc /sysroot/proc
/bin/busybox mount --move /sys /sysroot/sys
/bin/busybox mount --move /var /sysroot/var

if [ -f /sysroot/storage/.please_resize_me ] ; then
  INIT_UNIT="--unit=fs-resize.target"
fi

# switch to new sysroot and start real init
exec /bin/busybox switch_root /sysroot /usr/lib/systemd/systemd $INIT_ARGS $INIT_UNIT

error "switch_root" "Error in initramfs. Could not switch to new root"
