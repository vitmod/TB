#!/bin/bash

################################################################################
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
################################################################################

################################################################################
# variables such as $ROOT $PATH etc... that are required for this
# script to work must be passed via env ... in scripts/image
################################################################################

# functions
mount_loop() {
  mount "$LOOP" "$OE_TMP"
}

umount_loop() {
  sync
  umount "$OE_TMP" &>/dev/null || :
  umount "$LOOP" &>/dev/null || :
  losetup -d "$LOOP" &>/dev/null || :
}

cleanup() {
  echo "image: cleanup..."
  umount_loop
  [ -f "$OE_TMP/ldlinux.sys" ] && chattr -i "$OE_TMP/ldlinux.sys" || :
  rm -rf "$OE_TMP"
}

# set variables
OE_TMP=$(mktemp -d)
LOOP=$(losetup -f)

PART1_SIZE=256
PART2_SIZE=32 # PART2_SIZE must be >= 32 !

IMAGE_SIZE=$(( $PART1_SIZE + $PART2_SIZE + 4 ))
IMAGE="$TARGET_IMG/$IMAGE_NAME.img"

umount_loop
trap cleanup SIGINT

# generate volume id for fat partition
UUID1=$(date '+%d%m')
UUID2=$(date '+%M%S')
PART1_VOLID="${UUID1}${UUID2}"
PART1_UUID="${UUID1}-${UUID2}"

echo "image: creating image: $IMAGE..."
dd if=/dev/zero of="$IMAGE" bs=1M count="$IMAGE_SIZE" &>/dev/null
sync

echo "image: creating partitions..."
PART1_END=$(( $PART1_SIZE * 1024 * 1024 / 512 + 2048 ))
PART2_START=$(( $PART1_END + 2048 ))
PART2_END=$(( $PART2_START + (( $PART2_SIZE * 1024 * 1024 / 512 )) ))
losetup "$LOOP" "$IMAGE"
parted -s "$LOOP" mklabel msdos
parted -s "$LOOP" -a min unit s mkpart primary fat32 2048 $PART1_END
parted -s "$LOOP" set 1 boot on
parted -s "$LOOP" -a min unit s mkpart primary ext4 $PART2_START $PART2_END
umount_loop

echo "image: copying files..."
losetup -o $(( 2048 * 512 )) --sizelimit $(( $PART1_SIZE * 1024 * 1024 )) "$LOOP" "$IMAGE"
mkfs.vfat -i "$PART1_VOLID" "$LOOP" &>/dev/null
mount_loop
cp $TARGET_IMG/$IMAGE_NAME.kernel "$OE_TMP/kernel.img"
cp $TARGET_IMG/$IMAGE_NAME.system "$OE_TMP/root.sqfs"
umount_loop

echo "image: adding resize mark on part2..."
losetup -o $(( $PART2_START * 512 )) --sizelimit $(( $PART2_SIZE * 1024 * 1024 )) "$LOOP" "$IMAGE"
mke2fs -q -t ext4 -m 0 "$LOOP" &>/dev/null
e2fsck -n "$LOOP" &>/dev/null
mount_loop
touch "$OE_TMP/.please_resize_me"
umount_loop

echo "image: compressing..."
gzip $IMAGE

if [ -n "$SUDO_USER" ] ; then
  chown $SUDO_USER: $IMAGE.gz
fi

sync
cleanup
